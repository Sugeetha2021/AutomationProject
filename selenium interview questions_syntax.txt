Selenium Automation interview questions:

1. What is Selenium? What are its components?
Answer: Selenium is an open-source automation testing tool for web applications. It supports multiple programming languages (e.g., Java, Python, C#) and browsers.
Components of Selenium:
•	Selenium IDE: Record and playback tool.
•	Selenium WebDriver: Automates browser actions using programming.
•	Selenium Grid: Runs tests on multiple machines and browsers in parallel.
________________________________________
2. What is the difference between findElement() and findElements()?
Answer:
•	findElement(): Returns the first web element matching the locator. Throws NoSuchElementException if no element is found.
•	findElements(): Returns a list of all web elements matching the locator. Returns an empty list if no elements are found.
________________________________________
3. What are locators in Selenium?
Answer: Locators are used to identify elements on a webpage. Types of locators:
•	ID
•	Name
•	Class Name
•	XPath
•	CSS Selector
•	Tag Name
•	Link Text
•	Partial Link Text
________________________________________
4. What is the difference between Absolute XPath and Relative XPath?
Answer:
•	Absolute XPath: Specifies the complete path starting from the root node. Example: /html/body/div[1]/div[2].
•	Relative XPath: Begins from the current node or a specific node. Example: //div[@class='example'].
________________________________________
5. What are the advantages of Selenium WebDriver over Selenium IDE?
Answer:
•	Supports multiple programming languages.
•	Can handle dynamic web elements.
•	Enables advanced actions like handling alerts, frames, and file uploads.
•	Allows integration with frameworks like TestNG, Maven, etc.
________________________________________
Intermediate Questions
6. How do you handle dynamic elements in Selenium?
Answer: Dynamic elements have IDs or attributes that change with every page load. To handle them:
•	Use dynamic XPath or CSS Selectors:
java
CopyEdit
driver.findElement(By.xpath("//button[contains(text(),'Login')]"));
driver.findElement(By.xpath("//input[starts-with(@id,'user_')]"));
•	Use regular expressions or strategies like contains(), starts-with() in XPath.
________________________________________
7. What is TestNG, and why is it used in Selenium?
Answer: TestNG (Testing Next Generation) is a testing framework in Java used with Selenium for:
•	Defining test methods using annotations like @Test, @BeforeMethod, etc.
•	Running tests in parallel.
•	Generating detailed reports.
•	Managing dependencies and grouping tests.
________________________________________
8. How do you handle alerts in Selenium?
Answer: Alerts are handled using the Alert interface:

Alert alert = driver.switchTo().alert();
alert.accept(); // To click OK
alert.dismiss(); // To click Cancel
alert.sendKeys("Hello, TestNG!"); 
String alertText = alert.getText(); // To get the alert message
________________________________________
9. How do you handle a dropdown in Selenium?
Answer: Use the Select class to handle dropdowns:

Select dropdown = new Select(driver.findElement(By.id("dropdownId")));
dropdown.selectByVisibleText("Option1");
dropdown.selectByValue("value1");
dropdown.selectByIndex(2);
________________________________________
10. What is the Page Object Model (POM)?
Answer: POM is a design pattern in Selenium where each web page is represented as a class. The class contains:
Each page in the application is required to have its own corresponding java class in the project framework
Web UI elements on a page,will be stored as object in the corresponding java classes in the framework.
•	Web elements as variables.
•	Methods for performing actions on the web page.
Advantages of POM:
•	Improves readability and maintainability.
•	Reusability of code.
________________________________________
Advanced Questions
11. How do you perform cross-browser testing in Selenium?
Answer: Use WebDriver to specify the browser driver for testing:
Inside the frame work in base class we need to create a logic 
WebDriver driver;
public WebDriver initializeBrowserAndOpenAppURL(String browserName) {
	
	
	if (browserName.equalsIgnoreCase("chrome")) {
		
		driver =new ChromeDriver();
		
	}else if(browserName.equalsIgnoreCase("firefox")) {
		
		driver =new FirefoxDriver();
		
	}else if(browserName.equalsIgnoreCase("edge")) {
		
		driver =new EdgeDriver();
		
	}else if(browserName.equalsIgnoreCase("safari")) {
			
			driver =new SafariDriver();
	}
You can parameterize the browser name using TestNG or Maven.
Inside the test case login file we need toinclude the lines as
_driver= initializeBrowserAndOpenAppURL(prop.getProperty("browser"));
_______________________________________
12. How do you handle a file upload in Selenium?
Answer: For file uploads, use sendKeys to specify the file path:
From the system Downloads:

Driver.findelements(By.id(“uploadFile”)).sendKeys("C:\\path\\to\\file.txt");

From the Project folder file:

String ProjectPath= system.getProperty(“user.dir”);
Driver.findelements(By.id(“uploadFile”)).
sendkeys(projectPath+\\file\\wave.jpg);
________________________________________
13. What are Explicit Waits, Implicit Waits, and Fluent Waits?
Answer:
•	Implicit Wait: Sets a global wait time for locating elements.

driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

•	Explicit Wait: Waits for a specific condition to be met.

WebDriverWait wait = new WebDriverWait(driver, 10);
wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("elementId")));

•	Fluent Wait: Specifies polling intervals while waiting for a condition.

Wait<WebDriver> fluentWait = new FluentWait<>(driver)
    .withTimeout(Duration.ofSeconds(10))
    .pollingEvery(Duration.ofSeconds(2))
    .ignoring(NoSuchElementException.class);
fluentWait.until(ExpectedConditions.elementToBeClickable(By.id("elementId")));
________________________________________
14. How do you capture a screenshot in Selenium?
Answer: Use TakesScreenshot interface:
java

File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
String destinationPath = System.getProperty(“user.dir”)+”\\screenshot\\”+”Homepage.png”;
FileHandler.copy(screenshot, new File(destinationPath));
________________________________________
15. What is Selenium Grid, and how do you use it?
Answer: Selenium Grid is used for running tests on multiple machines and browsers in parallel.
Steps to Use Selenium Grid:
1.	Start the hub: java -jar selenium-server-standalone.jar -role hub
2.	Start the nodes: java -jar selenium-server-standalone.jar -role node
3.	Configure tests to point to the hub:

DesiredCapabilities capabilities = new DesiredCapabilities();
capabilities.setBrowserName("chrome");
WebDriver driver = new RemoteWebDriver(new URL("http://localhost:4444/wd/hub"), capabilities);
________________________________________
Scenario-Based Questions
16. How do you validate broken links on a webpage?
1. Manual Checking
•	Click on each link to see if it loads properly.
•	Look for 404 Not Found or other error messages.
2. Browser Developer Tools
•	Open Developer Tools (F12 or right-click > Inspect).
•	Go to the Console tab and reload the page.
•	Look for errors like 404 (Not Found).
3. Online Broken Link Checker Tools
Use free tools to scan your website:
•	Dead Link Checker
•	Broken Link Checker
•	W3C Link Checker
4. Automated Scripts (Python)
Use Python with the requests and BeautifulSoup libraries:
python
CopyEdit
import requests
from bs4 import BeautifulSoup

def check_links(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    for link in soup.find_all('a', href=True):
        link_url = link['href']
        try:
            res = requests.get(link_url, timeout=5)
            if res.status_code >= 400:
                print(f"Broken link: {link_url} (Status Code: {res.status_code})")
        except requests.exceptions.RequestException:
            print(f"Broken link: {link_url} (Failed to Connect)")

# Example usage
check_links('https://example.com')
5. SEO Tools
Platforms like Google Search Console or Ahrefs provide broken link reports.
If using Java, TestNG can be used with Selenium to automate broken link detection.

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.List;

public class BrokenLinksChecker {
    public static void main(String[] args) {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");

        List<WebElement> links = driver.findElements(By.tagName("a"));

        for (WebElement link : links) {
            String url = link.getAttribute("href");
            if (url != null && !url.isEmpty()) {
                checkBrokenLink(url);
            }
        }

        driver.quit();
    }

    public static void checkBrokenLink(String linkUrl) {
        try {
            URL url = new URL(linkUrl);
            HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();
            httpURLConnection.setRequestMethod("HEAD");
            httpURLConnection.connect();
            
            if (httpURLConnection.getResponseCode() >= 400) {
                System.out.println("Broken link: " + linkUrl + " (Status Code: " + httpURLConnection.getResponseCode() + ")");
            }
        } catch (Exception e) {
            System.out.println("Broken link: " + linkUrl + " (Failed to Connect)");
        }
    }
}
________________________________________
3. Using Cypress (JavaScript)
Cypress is a modern automation tool for testing web applications.

describe('Check for broken links', () => {
  it('Validates all links on the page', () => {
    cy.visit('https://example.com');
    
    cy.get('a').each(($el) => {
      const url = $el.prop('href');
      if (url) {
        cy.request(url).then((resp) => {
          expect(resp.status).to.be.lt(400);
        });
      }
    });
  });
});
________________________________________
4. Using a CI/CD Pipeline for Automated Checks
•	Integrate link checking into CI/CD pipelines with tools like Broken Link Checker in GitHub Actions.
•	Use SiteImprove, Screaming Frog SEO Spider, or Ahrefs for automated link validation.
Would you like guidance on integrating this into your automation framework? 🚀

Answer: Use HttpURLConnection in Java to check the HTTP response code:

List<WebElement> links = driver.findElements(By.tagName("a"));
for (WebElement link : links) {
    String url = link.getAttribute("href");
    HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
    conn.setRequestMethod("HEAD");
    int responseCode = conn.getResponseCode();
    if (responseCode != 200) {
        System.out.println("Broken Link: " + url);
    }
}
________________________________________
17.How to handle stale element exception
A StaleElementReferenceException occurs in Selenium when an element that was previously found is no longer attached to the DOM. This typically happens when the page refreshes, elements are dynamically updated, or the DOM structure changes.
Ways to Handle StaleElementReferenceException
1. Use Explicit Wait (Recommended)
Before interacting with an element, wait until it becomes available again using WebDriverWait.
python
CopyEdit
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver.get("your_website_url")

wait = WebDriverWait(driver, 10)  # Wait up to 10 seconds

element = wait.until(EC.presence_of_element_located((By.ID, "your_element_id")))
element.click()
________________________________________
2. Try Retrieving the Element Again
If the element becomes stale, locate it again before performing any action.
python
CopyEdit
from selenium.common.exceptions import StaleElementReferenceException

for _ in range(3):  # Retry 3 times
    try:
        element = driver.find_element(By.ID, "your_element_id")
        element.click()
        break  # If successful, exit the loop
    except StaleElementReferenceException:
        print("Element became stale. Retrying...")
________________________________________
3. Use a Small Delay
If the DOM is updating too quickly, a short sleep can sometimes help.
python
CopyEdit
import time

time.sleep(2)  # Short pause before re-locating the element
element = driver.find_element(By.ID, "your_element_id")
element.click()
________________________________________
4. Avoid Holding References to Elements
If possible, always find the element fresh just before interacting with it.
python
CopyEdit
element = driver.find_element(By.ID, "your_element_id")  # Locate fresh before each action
element.click()
________________________________________
5. Check if Element is Still Attached
Before interacting with an element, verify if it's still attached to the DOM.
python
CopyEdit
def is_element_stale(element):
    try:
        element.is_displayed()
        return False  # Element is still attached
    except StaleElementReferenceException:
        return True  # Element is stale

element = driver.find_element(By.ID, "your_element_id")

if is_element_stale(element):
    element = driver.find_element(By.ID, "your_element_id")  # Re-locate the element

element.click()
________________________________________
Best Practice
The most reliable approach is using Explicit Wait with presence_of_element_located(), as it ensures the element is present before interaction.
Let me know if you need help with a specific scenario! 🚀

18.what is mean by DOM
What is DOM? (Document Object Model)
The DOM (Document Object Model) is a structured representation of an HTML or XML document that browsers create when rendering a webpage. It acts as a tree-like hierarchy where each element (such as <div>, <p>, <button>, etc.) is represented as a node.
How DOM Works
When a browser loads a webpage:
1.	It parses the HTML document.
2.	It constructs a hierarchical DOM tree where each HTML tag is a node.
3.	JavaScript and Selenium WebDriver interact with this DOM to modify, retrieve, or manipulate elements dynamically.

19. How do you scroll a webpage using Selenium?
Answer: Use JavaScriptExecutor for scrolling:
java
CopyEdit
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("window.scrollBy(0,500)"); // Scroll down
________________________________________
20. How do you debug a failing Selenium test?
Answer:
1.	Check the error message and stack trace.
2.	Validate the locators used (e.g., XPath, CSS).
3.	Use debugging tools like breakpoints in the IDE.
4.	Capture screenshots for failed tests.
5.	Add explicit waits for synchronization issues.
________________________________________
21.	What are the different components of your automation framework?
A TestNG Automation Framework typically consists of several components that help in structuring and executing automated test cases effectively. Here are the main components:
________________________________________
1. TestNG Configuration File (testng.xml)
•	Defines test suite structure.
•	Allows grouping, parallel execution, and parameterization.
Example:
xml
CopyEdit
<suite name="Test Suite" parallel="tests" thread-count="2">
    <test name="Login Test">
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>
</suite>
________________________________________
2. Base Test Class (BaseTest.java)
•	Handles common setup (@BeforeSuite, @BeforeMethod) and teardown (@AfterSuite, @AfterMethod).
•	Initializes WebDriver, Browser settings, and Test Reports.
Example:
java
CopyEdit
public class BaseTest {
    protected WebDriver driver;

    @BeforeSuite
    public void setup() {
        driver = new ChromeDriver();
        driver.manage().window().maximize();
    }

    @AfterSuite
    public void teardown() {
        if (driver != null) {
            driver.quit();
        }
    }
}
________________________________________
3. Page Object Model (POM)
•	Separates UI elements from test scripts.
•	Maintains a Page Class for each webpage.
Example:
java
CopyEdit
public class LoginPage {
    private WebDriver driver;

    @FindBy(id = "username")
    WebElement username;

    @FindBy(id = "password")
    WebElement password;

    @FindBy(id = "loginButton")
    WebElement loginButton;

    public LoginPage(WebDriver driver) {
        this.driver = driver;
        PageFactory.initElements(driver, this);
    }

    public void login(String user, String pass) {
        username.sendKeys(user);
        password.sendKeys(pass);
        loginButton.click();
    }
}
________________________________________
4. Test Cases (Test Classes)
•	Extends BaseTest
•	Uses @Test annotation to define test methods.
•	Calls Page Object methods.
Example:
java
CopyEdit
public class LoginTest extends BaseTest {
    @Test
    public void verifyLogin() {
        driver.get("https://example.com");
        LoginPage loginPage = new LoginPage(driver);
        loginPage.login("admin", "password");
        Assert.assertEquals(driver.getTitle(), "Dashboard");
    }
}
________________________________________
5. Utility Classes (Utils.java)
•	Handles Common Functions, Property File Handling, Screenshots, etc.
Example: Screenshot Utility
java
CopyEdit
public class ScreenshotUtil {
    public static void takeScreenshot(WebDriver driver, String fileName) {
        File src = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(src, new File("screenshots/" + fileName + ".png"));
    }
}
________________________________________
6. Data-Driven Testing (Excel/CSV Handling)
•	Reads test data from external sources like Excel.
•	Uses Apache POI for Excel handling.
Example:
java
CopyEdit
public class ExcelUtil {
    public static String getData(String sheetName, int row, int col) {
        FileInputStream fis = new FileInputStream("TestData.xlsx");
        Workbook wb = new XSSFWorkbook(fis);
        return wb.getSheet(sheetName).getRow(row).getCell(col).getStringCellValue();
    }
}
________________________________________
7. Test Reports (Extent Reports/Allure)
•	Generates HTML test reports with logs and screenshots.
Example: Extent Report Integration
java
CopyEdit
public class ReportUtil {
    static ExtentReports extent;
    static ExtentTest test;

    public static void startReport() {
        extent = new ExtentReports("reports/extentReport.html", true);
    }

    public static void logTest(String message) {
        test.log(LogStatus.INFO, message);
    }

    public static void endReport() {
        extent.flush();
        extent.close();
    }
}
________________________________________
8. Parallel Execution (Cross-Browser Testing)
•	Executes tests on multiple browsers using testng.xml.
Example:
xml
CopyEdit
<suite name="Parallel Execution" parallel="tests" thread-count="2">
    <test name="Chrome Test">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="tests.LoginTest"/>
        </classes>
    </test>
</suite>
________________________________________
9. Continuous Integration (CI/CD)
•	Integrates with Jenkins, GitHub Actions, or GitLab CI.
•	Uses Maven/Gradle for dependency management.
________________________________________
Conclusion
A well-structured TestNG automation framework includes: ✅ TestNG.xml (Configuration)
✅ BaseTest (Setup & Teardown)
✅ Page Object Model (POM) (Reusable UI elements)
✅ Test Cases (Using Page Objects)
✅ Utilities (Data handling, screenshots, logging)
✅ Reports (Extent Reports, Allure)
✅ Parallel Execution (Cross-browser testing)
✅ CI/CD Integration (Jenkins, GitHub Actions)


2️2)Difference Between Data-Driven & Keyword-Driven Frameworks? Which is Preferred?
Feature	Data-Driven Framework	                                                         Keyword-Driven Framework
Definition	Uses external data sources (Excel, JSON, CSV, Database) for testing.	Uses predefined keywords to drive test execution.
Test Script Dependency	Scripts are independent of test data.	                    Test cases are controlled by keywords, reducing script complexity.
Complexity	More code-heavy.	                                                    Less coding, easier for non-programmers.
Reusability	Data can be reused across multiple test cases.	                        Keywords can be reused across different test cases.
🔹 Preferred Framework?
•	Hybrid Framework (Combination of Data-Driven + Keyword-Driven) is preferred for better maintainability and flexibility.
________________________________________
23)What Version Control Platform Are You Using?
•	Common answers: Git, GitHub, GitLab, Bitbucket, SVN.
•	If using GitHub:
o	"We use GitHub as our version control platform to manage our automation scripts collaboratively."
________________________________________
24)Commands to Commit & Push Code to Repository?
sh
CopyEdit
git add .
git commit -m "Your commit message"
git push origin main  # (or branch name)
________________________________________
25)Do You Execute Tests Locally or Use CI/CD Pipeline?
🔹 "We execute tests both locally and via CI/CD pipeline."
•	Locally for debugging & quick validation.
•	CI/CD (Jenkins, GitHub Actions, GitLab CI/CD) for automated test execution in different environments.
Process in CI/CD:
1.	Developer pushes code to the repository.
2.	CI/CD triggers test execution.
3.	Automated tests run on different environments (e.g., Selenium Grid, Docker).
4.	Results are published, and reports/logs are generated.
________________________________________
26)How Do You Generate Test Results?
•	TestNG Reports (test-output/index.html)
•	Extent Reports (Customized HTML reports)
•	Allure Reports (Detailed reports with logs, screenshots)
•	Jenkins Reports (CI/CD integration)
Example in TestNG:
java
CopyEdit
@AfterMethod
public void tearDown(ITestResult result) {
    if (result.getStatus() == ITestResult.FAILURE) {
        System.out.println("Test Failed: " + result.getName());
    }
}
________________________________________
27)How Do You Take a Screenshot?
java
CopyEdit
File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
Files.copy(screenshot.toPath(), Paths.get("screenshots/test.png"), StandardCopyOption.REPLACE_EXISTING);
________________________________________
28)What Coding Standards Do You Follow for Test Scripting?
✔ Camel Case Naming: testLoginPage(), clickSubmitButton()
✔ Adding Comments: // Click on Submit Button
✔ Avoiding Sleep Commands: Use Explicit Waits instead.
✔ Code Review: Peer review before merging code.
✔ Version Control: Commit small, meaningful changes frequently.
________________________________________
29)What Is POM (Page Object Model)?
Page Object Model (POM) is a design pattern in Selenium that enhances maintainability by separating UI elements from test scripts.
Example POM Structure:
java
CopyEdit
public class LoginPage {
    WebDriver driver;

    @FindBy(id="username") WebElement username;
    @FindBy(id="password") WebElement password;
    @FindBy(id="loginBtn") WebElement loginButton;

    public void login(String user, String pass) {
        username.sendKeys(user);
        password.sendKeys(pass);
        loginButton.click();
    }
}
________________________________________
30) How Do You Pass Test Data to Selenium Tests?
✔ Using Excel (Apache POI):
✔ Using JSON, CSV, or Database:
✔ Using TestNG DataProvider:
java
CopyEdit
@DataProvider(name = "loginData")
public Object[][] getData() {
    return new Object[][] {
        {"user1", "pass1"},
        {"user2", "pass2"}
    };
}

@Test(dataProvider = "loginData")
public void testLogin(String username, String password) {
    loginPage.login(username, password);
}
________________________________________
31)What Improvements Have You Made in Test Automation Framework?
✔ Implemented Parallel Execution (Selenium Grid, TestNG)
✔ Integrated CI/CD (Jenkins, GitHub Actions, GitLab CI/CD)
✔ Replaced Thread.sleep() with Explicit Waits
✔ Added Screenshot Logging for Failures
✔ Optimized Locators (Avoiding Absolute XPaths)
________________________________________
32)Can We Automate Dropdown Without Select Class?
✔ Yes! Using JavaScriptExecutor or Actions Class:

WebElement dropdown = driver.findElement(By.id("dropdownId"));
dropdown.click();
driver.findElement(By.xpath("//option[text()='Option1']")).click();

JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].click();", dropdown);
________________________________________
33)What Type of Exceptions Have You Encountered in Automation?
🔹 StaleElementReferenceException – Element is no longer attached to the DOM.
🔹 NoSuchElementException – Unable to locate the element.
🔹 TimeoutException – Element not found within the specified time.
🔹 ElementClickInterceptedException – Another element is overlapping.
🔹 InvalidSelectorException – Incorrect XPath or CSS selector.


________________________________________
34)What Is XPath?
XPath (XML Path Language) is used to locate web elements in Selenium.
Example XPath Types:
✔ Absolute XPath: "/html/body/div[1]/input" ❌ (Not recommended)
✔ Relative XPath: "//input[@id='username']" ✅ (Recommended)
✔ Contains(): "//button[contains(text(),'Login')]" ✔ Using AND/OR: "//input[@type='text' and @name='user']" ✔ Parent-Child Relationship: "//div[@class='header']/child::button"
________________________________________
35)2.	When do you use Explicit wait?
Explicit wait in Selenium is a synchronization mechanism that allows the WebDriver to wait for a specific condition to occur before proceeding with the next step in the code.
There are 2 types of Explicit wait types of Explicit wait 
•	Webdriver wait-Wait for the condition or element to be appear on the web page default polling time will be half sec.ear on the web page default polling time will be half sec.
•	Fluent wait: Wait for the condition it a advanced method of wait where we can customized the polling time.
--------------------------------------------
36)How do you handle dynamic web elements in Selenium?
Dynamic web elements have attributes like changing IDs, classes, or XPath, making them hard to locate. Here are ways to handle them:

✅ 1. Use Relative XPath instead of Absolute XPath
Avoid:

xpath
Copy
Edit
/html/body/div[1]/div[2]/table/tbody/tr[3]/td[2]
Better:

xpath
Copy
Edit
//table[@id='productTable']//td[contains(text(), 'Laptop')]
✅ 2. Use Contains, Starts-with, and Ends-with in XPath
contains() (for partial matching)
xpath
Copy
Edit
//input[contains(@id, 'dynamic_')]
starts-with()
xpath
Copy
Edit
//button[starts-with(@id, 'btn_')]
ends-with() (CSS Selector workaround)
css
Copy
Edit
[id$='dynamic']
✅ 3. Use Dynamic Waits Instead of Thread.sleep()
java
Copy
Edit
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("dynamicElement")));
✅ 4. JavaScript Executor (When Elements are Not Detectable)
java
Copy
Edit
JavascriptExecutor js = (JavascriptExecutor) driver;
WebElement element = (WebElement) js.executeScript("return document.querySelector('input.dynamicClass')");
-------------------------------------------------------------------------
37)How do you handle multiple windows in Selenium?
When a new tab or window opens, switch to it using getWindowHandles().

✅ 1. Switching Between Windows

String mainWindow = driver.getWindowHandle();  // Store parent window
Set<String> allWindows = driver.getWindowHandles(); // Get all open windows

for (String window : allWindows) {
    if (!window.equals(mainWindow)) {
        driver.switchTo().window(window);  // Switch to new window
        System.out.println("New Window Title: " + driver.getTitle());
        driver.close();  // Close new window
    }
}

driver.switchTo().window(mainWindow); // Switch back to parent
✅ 2. Switching to a Specific Window by Title
java
Copy
Edit
for (String handle : driver.getWindowHandles()) {
    driver.switchTo().window(handle);
    if (driver.getTitle().equals("Target Window Title")) {
        break;
    }
}
----------------------------------------------------------------------------------------------
38) How will you test broken links on a webpage?
A broken link returns an HTTP status 404 (Not Found).

✅ 1. Using Java’s HTTPURLConnection
java
Copy
Edit
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.List;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;

public class BrokenLinksTest {
    public static void main(String[] args) {
        WebDriver driver = new ChromeDriver();
        driver.get("https://example.com");

        List<WebElement> links = driver.findElements(By.tagName("a"));

        for (WebElement link : links) {
            String url = link.getAttribute("href");
            verifyLink(url);
        }

        driver.quit();
    }

    public static void verifyLink(String linkUrl) {
        try {
            HttpURLConnection conn = (HttpURLConnection) new URL(linkUrl).openConnection();
            conn.setRequestMethod("HEAD");
            conn.connect();
            int responseCode = conn.getResponseCode();

            if (responseCode >= 400) {
                System.out.println(linkUrl + " is a broken link");
            } else {
                System.out.println(linkUrl + " is valid");
            }
        } catch (Exception e) {
            System.out.println(linkUrl + " could not be checked");
        }
    }
}
39)How will you test the HTML page source using Selenium?
✅ 1. Get Page Source and Validate Content

String pageSource = driver.getPageSource();

if (pageSource.contains("<title>My Page Title</title>")) {
    System.out.println("Page title is present");
} else {
    System.out.println("Page title is missing");
}
✅ 2. Validate Meta Tags

WebElement metaTag = driver.findElement(By.xpath("//meta[@name='description']"));
System.out.println("Meta Tag: " + metaTag.getAttribute("content"));
---------------------------------------------------------------------------------
40. How will you scroll down to a particular web element in a webpage?
If an element is not in view, scroll to it using JavaScript Executor.

✅ 1. Scroll Directly to an Element

WebElement element = driver.findElement(By.id("targetElement"));
((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", element);
✅ 2. Scroll to Bottom of Page

((JavascriptExecutor) driver).executeScript("window.scrollTo(0, document.body.scrollHeight);");
✅ 3. Scroll by Pixels

((JavascriptExecutor) driver).executeScript("window.scrollBy(0,500);"); // Scroll down 500px
------------------------------------------------------------------------------------------
41. What are the challenges you have faced during automation? How did you overcome them?
Here are common Selenium automation challenges and how to overcome them:

🔥 1. Handling Dynamic Elements
Issue: Element IDs and attributes change dynamically.
✅ Solution: Use XPath functions (contains(), starts-with()), and explicit waits.

🔥 2. Handling Pop-ups and Alerts
Issue: Unexpected pop-ups break execution.
✅ Solution: Use Alert class for JavaScript alerts or AutoIT/Sikuli for OS pop-ups.

🔥 3. Dealing with Page Load Delays
Issue: Pages load at different speeds, causing ElementNotFoundException.
✅ Solution: Use explicit waits (WebDriverWait) instead of Thread.sleep().

🔥 4. Captcha and OTP Handling
Issue: Captcha and OTP prevent automated login.
✅ Solution:

Ask for test mode (disable Captcha in test environments).
Use third-party APIs like AntiCaptcha or manual intervention.
🔥 5. Handling Multi-Browser Testing
Issue: Test cases fail in different browsers due to inconsistencies.
✅ Solution: Use cross-browser testing tools like Selenium Grid, BrowserStack, or Sauce Labs.

🔥 6. Managing Test Data
Issue: Hardcoded data makes tests unreliable.
✅ Solution: Use DataProvider (TestNG) or read data from Excel/DB.

🔥 7. Performance Issues
Issue: Selenium tests run slower due to UI interaction.
✅ Solution: Use headless browsers (Chrome Headless, PhantomJS) for faster execution.

Final Thoughts
Mastering Selenium automation means knowing how to handle dynamic elements, pop-ups, multiple windows, broken links, scrolling, and page source validation. 🚀
----------------------------------------------------------------------------------------------------------------

42)Scenarios That Cannot Be Automated with Selenium & TestNG 🚫
While Selenium is a powerful tool for web automation, certain scenarios are difficult or impossible to automate using Selenium + TestNG alone. Here are such scenarios:
________________________________________
1. CAPTCHA and OTP Authentication 🔐
❌ Why Can't We Automate?
•	CAPTCHA (Completely Automated Public Turing test) is designed to block bots from automating processes.
•	OTP (One-Time Passwords) changes dynamically and requires external input.
✅ Workarounds
•	Disable CAPTCHA in the test environment (Ask developers for a test mode).
•	Use third-party APIs like AntiCaptcha or 2Captcha to bypass CAPTCHAs.
•	Fetch OTP from email/SMS using API (if the system allows).
________________________________________
2. File Upload/Download (OS-Level Dialogs) 📂
❌ Why Can't We Automate?
•	Selenium cannot interact with OS-based file dialogs (e.g., Windows' File Explorer, macOS Finder).
✅ Workarounds
•	Use AutoIT (Windows) or Robot Class (Java) to handle file upload pop-ups.
•	Directly upload files using sendKeys() (only if the input field allows).
java
CopyEdit
driver.findElement(By.id("uploadFile")).sendKeys("C:\\path\\to\\file.txt");
________________________________________
3. Desktop/Mobile Application Testing 💻📱
❌ Why Can't We Automate?
•	Selenium only supports web applications running in a browser.
•	Cannot interact with native desktop applications (e.g., Notepad, Calculator).
✅ Workarounds
•	Use Appium for mobile apps (Android/iOS).
•	Use Sikuli, AutoIT, or WinAppDriver for desktop applications.
________________________________________
4. Browser Notifications & Alerts (Chrome, Firefox, Edge) 🔔
❌ Why Can't We Automate?
•	Browser notifications (like location, camera, or push notifications) are outside the DOM, so Selenium can't interact with them.
✅ Workarounds
•	Disable notifications via ChromeOptions:
java
CopyEdit
ChromeOptions options = new ChromeOptions();
options.addArguments("--disable-notifications");
WebDriver driver = new ChromeDriver(options);
________________________________________
5. Audio & Video Streaming Tests (Media Playback) 🎥🎵
❌ Why Can't We Automate?
•	Selenium cannot verify if a video is playing or check sound output.
✅ Workarounds
•	Use Sikuli (image recognition) to detect video player progress.
•	Use JavaScript to check HTML5 video element status:
java
CopyEdit
JavascriptExecutor js = (JavascriptExecutor) driver;
boolean isPlaying = (Boolean) js.executeScript("return document.getElementById('video').paused === false;");
________________________________________
6. Multi-Tab/Session Testing (Same Browser, Different Users) 🔄
❌ Why Can't We Automate?
•	Selenium cannot maintain multiple user sessions in the same browser instance.
✅ Workarounds
•	Use incognito mode for separate sessions:
java
CopyEdit
ChromeOptions options = new ChromeOptions();
options.addArguments("--incognito");
WebDriver driver = new ChromeDriver(options);
•	Run tests in multiple browsers simultaneously.
________________________________________
7. Performance Testing (Page Load, Response Time) 🚀
❌ Why Can't We Automate?
•	Selenium does not provide detailed performance metrics like network latency, page load time, and server response time.
✅ Workarounds
•	Use JMeter, Lighthouse, or WebPageTest for performance testing.
•	Measure load time using JavaScript in Selenium:
java
CopyEdit
JavascriptExecutor js = (JavascriptExecutor) driver;
long loadTime = (Long) js.executeScript("return performance.timing.loadEventEnd - performance.timing.navigationStart;");
System.out.println("Page Load Time: " + loadTime + "ms");
________________________________________
8. Dynamic UI Elements with Heavy Animations 🎨
❌ Why Can't We Automate?
•	Some UI elements change dynamically (AJAX calls, animations, infinite scroll) and are difficult to locate.
✅ Workarounds
•	Use explicit waits (WebDriverWait):
java
CopyEdit
WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("dynamicElement")));
•	Use JavaScript Executor if WebDriver can't detect it:
java
CopyEdit
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].click();", driver.findElement(By.id("animatedButton")));
________________________________________
9. Email Verification (Email-Based Testing) 📧
❌ Why Can't We Automate?
•	Selenium cannot access email inboxes (like Gmail, Outlook) to verify confirmation links or OTPs.
✅ Workarounds
•	Use Java Mail API or Gmail API to read emails.
•	Use temporary mail services (like Mailinator) for automation.
________________________________________
10. Testing Database Validations (Back-End) 🗄️
❌ Why Can't We Automate?
•	Selenium only interacts with the UI, not the database.
•	Cannot verify backend data changes directly.
✅ Workarounds
•	Use JDBC (Java Database Connectivity) to query the database:
java
CopyEdit
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/testdb", "user", "password");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE email='test@example.com'");
while (rs.next()) {
    System.out.println("User Found: " + rs.getString("username"));
}
conn.close();
________________________________________
Final Thoughts 💡
❌ Scenarios Not Automatable with Selenium	                      ✅ Workaround
CAPTCHA & OTP	                                                  Use test mode or external APIs
File Upload/Download	                                          Use AutoIT, Robot Class
Desktop Apps	                                                  Use Appium (mobile) or Sikuli (desktop)
Browser Notifications	                                          Disable via ChromeOptions
Video & Audio Streaming	                                          Use Sikuli or JavaScript
Multi-Session Testing	                                          Use incognito mode or multiple browsers
Performance Testing	                                              Use JMeter, Lighthouse
Dynamic UI Elements	                                              Use JavaScript Executor, WebDriverWait
Email Verification	                                              Use Java Mail API
Database Validation	                                              Use JDBC

----------------------------------------------------------------------------------------------------------------------
43)Can We Use assert Instead of if Logic in Selenium? ✅
Yes! Assertions (assert) are preferred over if conditions in Selenium with TestNG/JUnit because they automatically fail the test if the condition is not met, ensuring better test reliability.
________________________________________
🚀 Why Use assert Instead of if?
Aspect	                            Using assert ✅	                                                    Using if Logic ❌
Automatic Failure	                Fails the test immediately if the condition is false.	            Requires manual exception throwing.
Readability	                        Clear, concise, and structured.                              	    More complex with additional code.
TestNG/JUnit Integration	        Works well with testing frameworks.	                                Not ideal for reporting.
Maintains                           Test Flow	Stops execution at failure.	                            Continues execution even if validation fails.
________________________________________
📌 Example 1: Using assertEquals (Recommended)
Instead of using:
java
CopyEdit
String title = driver.getTitle();
if (title.equals("Expected Title")) {
    System.out.println("Test Passed");
} else {
    System.out.println("Test Failed");
}
Use:
java
CopyEdit
import org.testng.Assert;

String actualTitle = driver.getTitle();
String expectedTitle = "Expected Title";

Assert.assertEquals(actualTitle, expectedTitle, "Title mismatch!");
✅ If the titles don't match, the test fails automatically with the error:
java.lang.AssertionError: Title mismatch! expected [Expected Title] but found [Actual Title]
________________________________________
📌 Example 2: Using assertTrue (For Boolean Checks)
Instead of:
java
CopyEdit
boolean isDisplayed = driver.findElement(By.id("logo")).isDisplayed();
if (!isDisplayed) {
    System.out.println("Test Failed");
}
Use:
java
CopyEdit
Assert.assertTrue(driver.findElement(By.id("logo")).isDisplayed(), "Logo is not displayed!");
✅ This automatically fails the test if the element is not displayed.
________________________________________
📌 Example 3: Using assertFalse (For Negative Conditions)
Instead of:
java
CopyEdit
boolean isEnabled = driver.findElement(By.id("submit")).isEnabled();
if (isEnabled) {
    System.out.println("Button should be disabled, but it's enabled.");
}
Use:
java
CopyEdit
Assert.assertFalse(driver.findElement(By.id("submit")).isEnabled(), "Submit button should be disabled!");
✅ This fails if the button is enabled instead of disabled.
________________________________________
📌 Example 4: Handling Assertions in try-catch (Soft Assertions)
If you want the test to continue even after failure, use Soft Assertions from TestNG:
java
CopyEdit
import org.testng.asserts.SoftAssert;

SoftAssert softAssert = new SoftAssert();
softAssert.assertEquals(driver.getTitle(), "Expected Title", "Title is incorrect");
softAssert.assertTrue(driver.findElement(By.id("logo")).isDisplayed(), "Logo not found");

// Continue execution even after failure
softAssert.assertAll();  // Fails only here after executing all assertions
✅ Soft Assertions allow multiple validations before failing the test.
________________________________________
📌 Conclusion: Use assert Over if for Better Testing!
🔹 Use Assert.assertEquals() → To compare expected and actual values.
🔹 Use Assert.assertTrue() → To verify if a condition is true.
🔹 Use Assert.assertFalse() → To check if a condition is false.
🔹 Use SoftAssert → If you want to continue execution after failures.
--------------------------------------------------------------------------------------------------------------------------------------------
44)What is the difference between pom and page factory?
- POM is a design pattern
  Each Web Page has a separate java class file, where Web UI Elements of pages are stored as objects in their respective Java class files.
- Page Factory is a built-in Selenium Class
  Supports Page Object Model By initializing Page Objects automatically on creating instances.
------------------------------------------------------------------------------------------------------------------------------------------------------
45)Running APIs Using Newman
Step	                            Command
Install Newman	                    npm install -g newman
Run Collection	                    newman run collection.json
Run with Environment	            newman run collection.json -e environment.json
Generate HTML Report	            newman run collection.json -r html --reporter-html-export report.html
Run in Parallel	                    newman run collection.json --iteration-count 3 --delay-request 1000
---------------------------------------------------------------------------------------------------------------------------------------------------
46)Can We Run a Particular Test from a Class File in TestNG? ✅
Yes! In TestNG, you can run a specific test method from a class file in multiple ways:

🔥 Method 1: Using -Dtest in Command Line
You can run a specific test method using the command line with Maven:
Syntax:
mvn test -Dtest=YourTestClass#yourTestMethod
Example:
If you have a class LoginTest.java with a method validLoginTest(), run:
mvn test -Dtest=LoginTest#validLoginTest
✅ This executes only the validLoginTest() method.

🔥 Method 2: Using include in testng.xml
Modify testng.xml to run a specific test method.

🔹 Example: Run Only testMethod2
xml
Copy
Edit
<suite name="TestSuite">
    <test name="Specific Test">
        <classes>
            <class name="com.example.TestClass">
                <methods>
                    <include name="testMethod2"/>
                </methods>
            </class>
        </classes>
    </test>
</suite>
✅ This will only execute testMethod2() from TestClass.java.

🔥 Method 3: Using @Test(enabled = false)
If you want to skip some tests and run only a specific one, mark the others as:

Syntax:
@Test(enabled = false)
public void testMethod1() {
    System.out.println("This test will be skipped.");
}

@Test
public void testMethod2() {
    System.out.println("This test will run.");
}
✅ Only testMethod2() runs while testMethod1() is ignored.

🔥 Method 4: Using Groups in TestNG
If your tests are grouped, you can run a specific group.

🔹 Example: Group Tests
Syntax:
@Test(groups = {"smoke"})
public void loginTest() {
    System.out.println("Login test running...");
}

@Test(groups = {"regression"})
public void logoutTest() {
    System.out.println("Logout test running...");
}
Now, run only the smoke test in testng.xml:

Code:
<suite name="Suite">
    <test name="Run Smoke Tests">
        <groups>
            <run>
                <include name="smoke"/>
            </run>
        </groups>
        <classes>
            <class name="com.example.TestClass"/>
        </classes>
    </test>
</suite>
✅ Only loginTest() runs, skipping logoutTest().

🎯 Summary: Ways to Run a Particular Test
Method	                                          Command/Config
Maven CLI	                                      mvn test -Dtest=TestClass#methodName
Modify testng.xml	                              <include name="methodName"/>
Disable Tests	                                  @Test(enabled = false)
Run Test Groups                                   @Test(groups = {"regression"})Use <groups> in testng.xml
-------------------------------------------------------------------------------------------------------------------------------
47)Structure of testng.xml File in TestNG
A testng.xml file is used in TestNG to configure and organize test execution. It allows us to define test suites, tests, classes, methods, and groups in a structured way.

📌 Basic Structure of testng.xml

<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="SuiteName">
    <test name="TestName">
        <classes>
            <class name="com.example.TestClass1"/>
            <class name="com.example.TestClass2"/>
        </classes>
    </test>
</suite>
✅ This runs TestClass1 and TestClass2 under a test suite.

📌 Detailed Explanation of testng.xml Components
Tag	                                              Purpose
<!DOCTYPE suite>	                              Defines that this is a TestNG suite file
<suite>	                                          Defines a test suite (can contain multiple tests)
<test>	                                          Defines an individual test (can contain multiple classes)
<classes>	                                      Groups multiple test classes to be executed
<class>	                                          Defines a test class (full package name required)
<methods>	                                      Runs specific test methods inside a class
<groups>	                                      Groups test cases for selective execution
<parameters>	                                  Passes parameters to tests
🔥 Advanced testng.xml Example
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Regression Suite" parallel="tests" thread-count="2">

    <test name="Login Tests">
        <parameter name="browser" value="Chrome"/>
        <classes>
            <class name="com.example.LoginTest">
                <methods>
                    <include name="validLogin"/>
                    <exclude name="invalidLogin"/>
                </methods>
            </class>
        </classes>
    </test>

    <test name="Dashboard Tests">
        <classes>
            <class name="com.example.DashboardTest"/>
        </classes>
    </test>

</suite>
🔹 What This Does
Runs a Regression Suite in parallel with 2 threads.
Login Tests
Runs only validLogin(), skips invalidLogin().
Passes a parameter (browser=Chrome) to the test.
Dashboard Tests
Runs all tests in DashboardTest class.
🔥 Using Groups in testng.xml
You can use groups to run specific test types (e.g., smoke, regression).

🔹 Test Class with Groups
Syntax:
@Test(groups = {"smoke"})
public void loginTest() {
    System.out.println("Smoke test running...");
}

@Test(groups = {"regression"})
public void dashboardTest() {
    System.out.println("Regression test running...");
}
🔹 testng.xml to Run a Specific Group
<suite name="Suite">
    <test name="Run Smoke Tests">
        <groups>
            <run>
                <include name="smoke"/>
            </run>
        </groups>
        <classes>
            <class name="com.example.TestClass"/>
        </classes>
    </test>
</suite>
✅ Only loginTest() runs, skipping dashboardTest().

🔥 Running testng.xml from Command Line

mvn test -DsuiteXmlFile=testng.xml
OR
java -cp "testng.jar;bin" org.testng.TestNG testng.xml

🎯 Summary: Key Features of testng.xml
Feature	                                                  Description
Parallel Execution	                                      <suite parallel="tests" thread-count="2">
Run Specific Methods	                                  <include name="methodName"/>
Skip Methods	                                          <exclude name="methodName"/>
Run Groups	                                              <groups><run><include name="groupName"/></run></groups>
Pass Parameters	                                          <parameter name="key" value="value"/>
-------------------------------------------------------------------------------------------------------------------------------
48)Common TestNG Annotations Used in a Framework
TestNG provides various annotations to control the flow of test execution. Here are the most commonly used ones in a TestNG-based framework:

📌 1. Basic Test Annotations
Annotation	                        Description
@Test	                            Marks a method as a test case.
@BeforeMethod	                    Runs before each test method.
@AfterMethod	                    Runs after each test method.
@BeforeClass	                    Runs once before the first test in the class.
@AfterClass                     	Runs once after all tests in the class.
🔹 Example

public class SampleTest {
    
    @BeforeClass
    public void setUp() {
        System.out.println("Setup before the class execution");
    }

    @BeforeMethod
    public void beforeMethod() {
        System.out.println("Runs before each test method");
    }

    @Test
    public void testMethod1() {
        System.out.println("Executing Test Method 1");
    }

    @AfterMethod
    public void afterMethod() {
        System.out.println("Runs after each test method");
    }

    @AfterClass
    public void tearDown() {
        System.out.println("Cleanup after the class execution");
    }
}
✅ Execution Order: 1️⃣ BeforeClass → 2️⃣ BeforeMethod → 3️⃣ Test Method → 4️⃣ AfterMethod → 5️⃣ AfterClass

📌 2. Suite-Level Annotations
Annotation	                                        Description
@BeforeSuite	                                    Runs once before the entire test suite.
@AfterSuite	                                        Runs once after the entire test suite.
@BeforeTest	                                        Runs before each <test> block in testng.xml.
@AfterTest	                                        Runs after each <test> block in testng.xml.
🔹 Example

public class SuiteExample {

    @BeforeSuite
    public void beforeSuite() {
        System.out.println("Before the Test Suite");
    }

    @BeforeTest
    public void beforeTest() {
        System.out.println("Before each <test> block in testng.xml");
    }

    @AfterTest
    public void afterTest() {
        System.out.println("After each <test> block in testng.xml");
    }

    @AfterSuite
    public void afterSuite() {
        System.out.println("After the Test Suite");
    }
}
✅ Useful for:

Setting up WebDriver before all tests.
Closing browser after all tests.
📌 3. Data-Driven Testing Annotations
Annotation	                             Description
@DataProvider	                         Provides parameterized data for tests.
@Parameters	                             Reads values from testng.xml.
🔹 Example: @DataProvider
public class DataProviderExample {

    @DataProvider(name = "loginData")
    public Object[][] getData() {
        return new Object[][] {
            {"user1", "password1"},
            {"user2", "password2"}
        };
    }

    @Test(dataProvider = "loginData")
    public void loginTest(String username, String password) {
        System.out.println("Logging in with: " + username + " / " + password);
    }
}
✅ Runs the test multiple times with different data sets.

📌 4. Dependency & Execution Control Annotations
Annotation	                                 Description
@DependsOnMethods	                         Runs a test only if the dependent method passes.
@Priority	                                 Defines the execution order of tests.
@Enabled	                                 Enables or disables a test.
@AlwaysRun	                                 Ensures a test runs even if dependencies fail.
🔹 Example: @DependsOnMethods
public class DependencyExample {

    @Test
    public void loginTest() {
        System.out.println("Login successful");
    }

    @Test(dependsOnMethods = "loginTest")
    public void dashboardTest() {
        System.out.println("Dashboard accessed after login");
    }
}
✅ dashboardTest() runs only if loginTest() passes.

📌 5. Parallel & Timeout Annotations
Annotation	                                         Description
@Test(threadPoolSize = 3, invocationCount = 5)	     Runs a test in parallel threads.
@Test(timeOut = 5000)	                             Fails the test if it exceeds 5 seconds.
🔹 Example: Parallel Execution
@Test(threadPoolSize = 3, invocationCount = 5)
public void loadTest() {
    System.out.println("Executing in parallel");
}
✅ Runs 5 times in 3 threads.

🎯 Summary: Commonly Used TestNG Annotations
Annotation	                                           Purpose
@Test	                                               Defines a test method.
@BeforeMethod / @AfterMethod	                       Runs before/after each test method.
@BeforeClass / @AfterClass	                           Runs before/after all methods in a class.
@BeforeTest / @AfterTest	                           Runs before/after a <test> block in testng.xml.
@BeforeSuite / @AfterSuite	                           Runs before/after the entire test suite.
@DataProvider	                                       Provides test data dynamically.
@Parameters                                            Reads external parameters from testng.xml.
@DependsOnMethods	                                   Runs only if another test passes.
@Priority	                                           Controls the execution order.
@Enabled(false)	                                       Disables a test case.
@Test(threadPoolSize = 3)	                           Runs tests in parallel.
-------------------------------------------------------------------------------------------------------------------------------------
49)Have You Done Parallel Execution in TestNG?
Yes! Parallel execution is one of the key features of TestNG. It allows test cases to run simultaneously on multiple browsers or threads, reducing execution time.

📌 How Many Browsers Can Be Used?
You can run tests on multiple browsers (Chrome, Firefox, Edge, etc.) using Selenium Grid.
The number of browsers depends on system capability & thread configuration.
Typically, 2 to 4 browsers are run in parallel in most automation setups.
Cloud-based solutions like Sauce Labs, BrowserStack, or Selenium Grid can run dozens of browsers at the same time.
🔥 1️⃣ Parallel Execution Using testng.xml
TestNG allows parallel execution at suite, test, and method levels.

🔹 Example: Run Tests in Parallel (Thread Count = 2)

<suite name="Parallel Test Suite" parallel="tests" thread-count="2">
    <test name="Chrome Test">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="com.example.TestClass"/>
        </classes>
    </test>

    <test name="Firefox Test">
        <parameter name="browser" value="firefox"/>
        <classes>
            <class name="com.example.TestClass"/>
        </classes>
    </test>
</suite>
✅ This runs the same test on Chrome & Firefox simultaneously.

🔥 2️⃣ Parallel Execution with Selenium WebDriver
To use parallel execution in Selenium, modify your test setup:

🔹 WebDriver Setup Using @Parameters

public class ParallelTest {
    WebDriver driver;

    @BeforeMethod
    @Parameters("browser")
    public void setup(String browser) {
        if (browser.equalsIgnoreCase("chrome")) {
            driver = new ChromeDriver();
        } else if (browser.equalsIgnoreCase("firefox")) {
            driver = new FirefoxDriver();
        }
        driver.manage().window().maximize();
    }

    @Test
    public void testGoogle() {
        driver.get("https://www.google.com");
        System.out.println("Title: " + driver.getTitle());
    }

    @AfterMethod
    public void teardown() {
        driver.quit();
    }
}
✅ Each test runs in a separate browser instance.

🔥 3️⃣ Parallel Execution of Methods
You can run multiple test methods in parallel by modifying testng.xml:


<suite name="Suite" parallel="methods" thread-count="3">
    <test name="Parallel Methods">
        <classes>
            <class name="com.example.TestClass"/>
        </classes>
    </test>
</suite>
✅ Runs test methods in parallel, with 3 threads.

🔥 4️⃣ Parallel Execution Using DataProvider

@Test(dataProvider = "browsers", parallel = true)
public void testOnDifferentBrowsers(String browser) {
    WebDriver driver;
    
    if (browser.equals("chrome")) {
        driver = new ChromeDriver();
    } else {
        driver = new FirefoxDriver();
    }
    
    driver.get("https://example.com");
    System.out.println("Testing on " + browser);
    driver.quit();
}

@DataProvider(name = "browsers", parallel = true)
public Object[][] getBrowsers() {
    return new Object[][] { {"chrome"}, {"firefox"} };
}
✅ Runs multiple browsers in parallel using @DataProvider.

📌 Summary: Parallel Execution Options in TestNG
Execution Level	                                               How to Implement
Parallel Browsers	                                           Use parallel="tests" in testng.xml with browser parameters.
Parallel Methods	                                           Use parallel="methods" in testng.xml.
Parallel Classes	                                           Use parallel="classes" in testng.xml.
Parallel Data Sets	                                           Use @DataProvider(parallel = true).
🎯 How Many Browsers Are Running?
Typically 2 to 4 browsers for local execution.
Unlimited browsers using cloud platforms like Selenium Grid or BrowserStack.
-----------------------------------------------------------------------------------------------------------------------------------------------------
50)Use of dataprovider annotation?
The @DataProvider annotation in TestNG is used to provide multiple sets of test data to a test method, allowing data-driven testing. It helps execute the same test case with different inputs without duplicating the test code.

🎯 Key Points for Interviews
Supports data-driven testing by running a test multiple times with different inputs.
Returns a 2D object array (Object[][]) containing test data.
Can be used within the same class or from an external class.
Supports parallel execution to run tests faster.
Can fetch data from Excel, databases, or API responses.
🔹 Example 1: Basic Use of @DataProvider
💬 "Can you show how @DataProvider works?"

import org.testng.annotations.Test;
import org.testng.annotations.DataProvider;

public class LoginTest {

    @Test(dataProvider = "loginData")
    public void loginTest(String username, String password) {
        System.out.println("Logging in with: " + username + " | " + password);
        // Your Selenium login test logic here
    }

    @DataProvider(name = "loginData")
    public Object[][] getData() {
        return new Object[][] {
            {"user1@example.com", "password123"},
            {"user2@example.com", "pass456"},
            {"admin@example.com", "adminPass"}
        };
    }
}
✅ Test runs 3 times with different usernames and passwords.

🔹 Example 2: Using @DataProvider from an External Class
💬 "Can a @DataProvider be used from another class?"

Yes! Use dataProviderClass to refer to another class.

Data Provider Class:

import org.testng.annotations.DataProvider;

public class TestData {

    @DataProvider(name = "credentials")
    public static Object[][] provideCredentials() {
        return new Object[][] {
            {"admin", "admin123"},
            {"user", "userPass"}
        };
    }
}
Test Class:

import org.testng.annotations.Test;

public class DashboardTest {

    @Test(dataProvider = "credentials", dataProviderClass = TestData.class)
    public void verifyDashboard(String username, String password) {
        System.out.println("Testing with: " + username + " | " + password);
    }
}
✅ Keeps test data separate from test logic.

🔹 Example 3: Parallel Execution with @DataProvider
💬 "How can you run tests in parallel using @DataProvider?"


@DataProvider(name = "browsers", parallel = true)
public Object[][] browserData() {
    return new Object[][] {
        {"Chrome"},
        {"Firefox"},
        {"Edge"}
    };
}

@Test(dataProvider = "browsers")
public void testOnMultipleBrowsers(String browser) {
    System.out.println("Running test on: " + browser);
}
✅ Executes test cases on multiple browsers simultaneously.

🔹 Example 4: Fetching Data from Excel for @DataProvider
💬 "Can @DataProvider fetch test data from Excel?"

Yes! You can read data from Excel using Apache POI:


@DataProvider(name = "excelData")
public Object[][] readExcelData() {
    String filePath = "data.xlsx";
    // Code to read Excel using Apache POI
    return new Object[][] { {"User1", "Pass1"}, {"User2", "Pass2"} };
}
✅ Automates testing with real-world data.

🎯 Interview Cheat Sheet: @DataProvider
Question	                                                      Best Answer
What is @DataProvider in TestNG?	                              A method that supplies test data dynamically. It allows a test method to execute multiple times with different inputs.
What is the return type of @DataProvider?	                      It returns a 2D Object array (Object[][]).
How do you pass data from another class?	                      Use dataProviderClass = TestData.class.
Can @DataProvider run tests in parallel?	                      Yes, add parallel = true in the annotation.
Can we fetch test data from Excel or DB?	                      Yes, using Apache POI (Excel) or JDBC (Database).
What is the difference between @DataProvider and @Parameters?	  @DataProvider provides multiple sets of data, while @Parameters fetches single values from testng.xml.
🚀 Final Thoughts
@DataProvider is essential for scalable automation frameworks.
It eliminates hardcoded test data, improving flexibility.
Parallel execution speeds up test runs.
----------------------------------------------------------------------------------------------------------------------------------
51)What is an assertion in TestNG? How do you use it in Selenium automation?

📌 Answer:
An assertion in TestNG is used to validate test results by comparing expected and actual outcomes. If an assertion fails, the test case is marked as failed.

Assertions help ensure application correctness by checking if a specific condition is met.

🎯 Types of Assertions in TestNG
1️⃣ Hard Assertions (Assert class)

Stops execution immediately when an assertion fails.
Used for critical test validations.
Example: Assert.assertEquals(actual, expected).
2️⃣ Soft Assertions (SoftAssert class)

Allows test execution to continue even after assertion failure.
Reports all failures at the end using softAssert.assertAll().
Example: SoftAssert softAssert = new SoftAssert();.
🔹 Example 1: Hard Assertion (Assert)
💬 "How do you use hard assertions in Selenium?"

import org.testng.Assert;
import org.testng.annotations.Test;

public class HardAssertionExample {

    @Test
    public void testTitle() {
        String actualTitle = "Google";
        String expectedTitle = "Google";
        
        Assert.assertEquals(actualTitle, expectedTitle, "Title does not match!");
        
        System.out.println("This will execute only if assertion passes.");
    }
}
✅ If assertion fails, execution stops immediately.

🔹 Example 2: Soft Assertion (SoftAssert)
💬 "How do you continue execution after assertion failure?"

import org.testng.annotations.Test;
import org.testng.asserts.SoftAssert;

public class SoftAssertionExample {

    @Test
    public void testMultipleValidations() {
        SoftAssert softAssert = new SoftAssert();
        
        System.out.println("Step 1: Validating first condition");
        softAssert.assertEquals(5, 10, "Step 1 failed!");
        
        System.out.println("Step 2: Validating second condition");
        softAssert.assertTrue(false, "Step 2 failed!");
        
        System.out.println("Test execution continues...");
        
        softAssert.assertAll();  // Reports all failures at the end
    }
}
✅ All assertions are checked, and failures are reported at the end.

🔹 Example 3: Assertion in Selenium WebDriver
💬 "Can you show an example of using assertions in Selenium?"

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.testng.Assert;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

public class SeleniumAssertionTest {

    WebDriver driver;

    @BeforeMethod
    public void setup() {
        driver = new ChromeDriver();
        driver.get("https://www.google.com");
    }

    @Test
    public void validateTitle() {
        String actualTitle = driver.getTitle();
        String expectedTitle = "Google";

        Assert.assertEquals(actualTitle, expectedTitle, "Page title does not match!");
    }

    @AfterMethod
    public void teardown() {
        driver.quit();
    }
}
✅ Used Assert.assertEquals() to verify the page title.

📌 Hard vs. Soft Assertions - Key Differences
Feature                   	Hard Assertion (Assert)	                                                 Soft Assertion (SoftAssert)
Execution                   Behavior	Stops test immediately	                                     Continues execution
Test Failure Handling	    Fails test instantly	                                                 Reports all failures at the end
Common Usage	            Critical test conditions	                                             Multiple validations

🎯 Interview Cheat Sheet: Assertions in TestNG
Question	                                                    Best Answer
What is an assertion?	                                        It verifies expected vs. actual results in a test case.
What happens when an assertion fails?	                        In hard assertions, execution stops immediately. In soft assertions, test continues and reports failures at the end.
When to use soft assertions?	                                When you want multiple validations within a single test case without stopping execution.
Difference between assertEquals() and assertTrue()?	            assertEquals(actual, expected) compares values, assertTrue(condition) checks if a condition is true.
How do you assert a web element in Selenium?	                Use Assert.assertTrue(element.isDisplayed(), "Element not visible!");
🚀 Final Thoughts
Assertions are crucial for verifying test results in Selenium.
Use Assert for critical checks (e.g., page loads, login success).
Use SoftAssert for multiple validations in a single test.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
52)	Can final keyword be used with static keyword?
Can final and static keywords be used together in Java? If yes, how?

📌 Answer:
Yes! The final keyword can be used with the static keyword in Java. When used together, they provide constant-like behavior at the class level.

🔹 How final Works with static in Java
The static keyword means the variable/method belongs to the class, not instances.
The final keyword means the value cannot be changed after initialization.

📌 When combined (static final), it creates constants at the class level.

🔹 Example 1: static final Variable (Constant)
💬 "How do you declare a constant in Java?"

public class Constants {
    public static final double PI = 3.14159;
}
✅ Explanation:

static → PI belongs to the class, not an instance.
final → The value cannot be changed.
📌 Usage:

System.out.println(Constants.PI); // Output: 3.14159
🔹 Example 2: static final Method
💬 "Can a method be both static and final?"

public class Utility {

    public static final void printMessage() {
        System.out.println("Hello, world!");
    }
}
✅ Explanation:

static → Can be accessed without creating an object.
final → Cannot be overridden in a subclass.
🔹 Example 3: static final Class (Not Allowed)
💬 "Can a class be both static and final?"

No, a class cannot be static final because:
A static class is only allowed inside another class (nested class).
A final class cannot be extended, so making it static makes no sense.
✅ Valid Example:

class OuterClass {
    static final class InnerClass {
        void display() {
            System.out.println("Inside static final inner class");
        }
    }
}
🎯 Interview Cheat Sheet: static final
Question	                                             Best Answer
Can a variable be static final?	                         Yes, it creates a class-level constant.
Can a method be static final?	                         Yes, but it cannot be overridden in subclasses.
Can a class be static final?	                         Only nested classes can be static final.
Why use static final?	                                 To define constants (public static final int MAX_LIMIT = 100;).
🚀 Final Thoughts
static final is commonly used for constants (Math.PI, System.out).
static final methods cannot be overridden, ensuring utility methods remain unchanged.
Avoid using final static for classes—only nested classes can be static final.
---------------------------------------------------------------------------------------------------------------------------------------------------------
53)Difference Between Method Overloading and Method Overriding
Feature	           Method Overloading	                                                                                  Method Overriding

Definition	       Defining multiple methods with the same name but different parameters within the same class.           Redefining a method of the parent class in a subclass with the same signature.
Parameters	       Must have different parameter lists (different number or type of parameters).	                      Must have the same parameter list as the parent class method.
Return Type	       Can have different return types but should differ in parameters to avoid ambiguity.	                  Must have the same return type or a covariant return type (subtype of the original return type).
Scope	           Happens within the same class.	                                                                      Happens between parent and child classes (inheritance is required).
Access Modifiers   Can have any access modifier.	                                                                      Cannot reduce the visibility of the parent class method (e.g., public method in parent must remain public in child).
Static Methods	   Can overload static methods.	                                                                          Cannot override static methods; instead, they are hidden in the subclass.
Performance	       Typically resolved at compile-time (Compile-time polymorphism).	                                      Resolved at runtime (Runtime polymorphism).
Usage	           Used for improving code readability and reusability by providing multiple ways to call a method.	      Used for providing a specific implementation of a method that is already defined in a parent class.
Example of Method Overloading (Same Class)

class MathOperations {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
}
Example of Method Overriding (Inheritance)
class Parent {
    void display() {
        System.out.println("This is Parent class");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("This is Child class");
    }
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
54)Difference Between Abstract Class and Interface in Java


Feature	                Abstract Class	                                                                                                       Interface
Definition	            A class that cannot be instantiated and may have abstract (unimplemented) as well as concrete (implemented) methods.	A blueprint of a class that contains only abstract methods (before Java 8) or default/static methods (Java 8+).
Methods	                Can have both abstract and non-abstract (concrete) methods.	                                                            Before Java 8: Only abstract methods. After Java 8: Can have default and static methods.
Variables	            Can have instance variables (fields) with any access modifier.	                                                        Only allows public, static, and final variables (constants).
Access Modifiers	    Methods can be public, protected, or private.	                                                                        All methods are implicitly public and abstract (except default and static methods in Java 8+).
Constructor	            Can have a constructor.                                                                                              	Cannot have a constructor.
Inheritance	            A class can extend only one abstract class (single inheritance).	                                                    A class can implement multiple interfaces (multiple inheritance).
Implementation	        A subclass must implement all abstract methods unless it is also abstract.	                                            A class implementing an interface must provide implementations for all abstract methods.
Usage	                Used when classes share common behavior but also need some concrete methods.	                                        Used when multiple unrelated classes need to follow a common contract.
Performance	            Slightly faster than interfaces due to method resolution.	                                                            Slightly slower due to dynamic method lookup.
Example of Abstract Class

abstract class Animal {
    abstract void makeSound(); // Abstract method

    void sleep() { // Concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Barking...");
    }
}
Example of Interface

interface Animal {
    void makeSound(); // Abstract method (implicitly public)
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Barking...");
    }
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------
55)What is the use of static keyword?

The static keyword in Java is used for memory management and to define class-level elements that belong to the class rather than instances (objects).
It can be applied to variables, methods, blocks, and nested classes.

1. Static Variables (Class Variables)
Shared among all instances of a class.
Stored in method area (not heap memory).
Used for constants or shared resources.
Example:


class Employee {
    static String company = "TechCorp"; // Shared by all employees
    String name;

    Employee(String name) {
        this.name = name;
    }

    void display() {
        System.out.println(name + " works at " + company);
    }
}

public class Main {
    public static void main(String[] args) {
        Employee e1 = new Employee("Alice");
        Employee e2 = new Employee("Bob");

        e1.display();
        e2.display();
    }
}
Output:

Alice works at TechCorp
Bob works at TechCorp
2. Static Methods
Belong to the class, not objects.
Can be called without creating an instance.
Cannot access non-static (instance) members directly.
Example:


class MathUtils {
    static int square(int x) {
        return x * x;
    }
}

public class Main {
    public static void main(String[] args) {
        System.out.println(MathUtils.square(5)); // Calling without creating an object
    }
}
3. Static Blocks
Used for initializing static data members.
Executes when the class is loaded into memory (before the main method).
Example:


class Test {
    static {
        System.out.println("Static block executed!");
    }

    public static void main(String[] args) {
        System.out.println("Main method executed!");
    }
}
Output:


Static block executed!
Main method executed!
4. Static Nested Class
A class defined inside another class but marked as static.
Can access only static members of the outer class.
Example:


class Outer {
    static class Inner {
        void show() {
            System.out.println("Inside static nested class");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer.Inner obj = new Outer.Inner();
        obj.show();
    }
}
Key Points to Remember
✔ static variables and methods belong to the class, not instances.
✔ static blocks execute once when the class is loaded.
✔ static methods cannot access non-static members directly.
✔ static nested classes do not need an instance of the outer class.
-------------------------------------------------------------------------------------------------------------------------------------------------
56)Difference between function overloading and function overriding?

Function overloading and function overriding are both concepts in object-oriented programming but serve different purposes.

Function Overloading:
Definition: When multiple functions in the same class have the same name but different parameters (different type, number, or both).
Purpose: Provides multiple ways to call a function with different arguments.
Where it is used: In the same class.
Parameters: Must be different in number or type.
Return Type: Can be the same or different.
Inheritance: Not required.
Example (C++/Java):
cpp
Copy
Edit
class Math {
public:
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) {
        return a + b;
    }
};
java
Copy
Edit
class Math {
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) {
        return a + b;
    }
}
Function Overriding:
Definition: When a derived class provides a specific implementation of a function that is already defined in its base class.
Purpose: To provide a new implementation of an inherited function.
Where it is used: In a child class (subclass) that inherits from a parent class.
Parameters: Must be the same.
Return Type: Must be the same (or covariant in some languages like Java/C++).
Inheritance: Required.
Requires keyword: virtual in C++, @Override in Java (optional but recommended).
Example (C++/Java):
cpp
Copy
Edit
class Parent {
public:
    virtual void show() {
        cout << "Parent class show function" << endl;
    }
};
class Child : public Parent {
public:
    void show() override {
        cout << "Child class show function" << endl;
    }
};
java
Copy
Edit
class Parent {
    void show() {
        System.out.println("Parent class show function");
    }
}
class Child extends Parent {
    @Override
    void show() {
        System.out.println("Child class show function");
    }
}
Key Differences:
Feature	                                          Function Overloading	                                                               Function Overriding
Definition	                                      Multiple functions with the same name in the same class but different parameters.	   A child class provides a new implementation of a method in the parent class.
Scope	                                          Same class.	                                                                       Different classes (inheritance involved).
Parameters	                                      Must be different (type/number).	                                                   Must be the same.
Return Type	                                      Can be different.	                                                                   Must be the same (or covariant).
Inheritance	                                      Not required.	                                                                       Required.
Access Specifier	                              No restriction.	                                                                   Must have the same or broader access level (in Java, cannot reduce visibility).
Keyword	                                          Not required.	                                                                       Uses virtual in C++ and @Override in Java.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
57)Can we override the main method and why?

No, we cannot override the main method in Java because it is a static method.

Reasons Why the main Method Cannot Be Overridden:
Static Methods Cannot Be Overridden

In Java, method overriding requires inheritance and dynamic method dispatch (runtime polymorphism), which applies only to instance methods.
The main method is static, meaning it belongs to the class, not an instance. Static methods are resolved at compile time, not runtime.
Different Method Signature for Execution

The JVM specifically looks for public static void main(String[] args).
Even if a subclass defines another main method, it does not override the parent class's main method; it simply hides it.
Example of Hiding the main Method:

class Parent {
    public static void main(String[] args) {
        System.out.println("Parent class main method");
    }
}

class Child extends Parent {
    public static void main(String[] args) {
        System.out.println("Child class main method");
    }
}
Output if Child is run:


Child class main method
Output if Parent is run:

Parent class main method
Here, the main method in Child does not override Parent's main method—it just hides it.

Conclusion:
Overriding applies to instance methods.
Static methods like main are resolved at compile time, not runtime.
We can define another main method in a subclass, but it is method hiding, not overriding.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
58)How you will drag and drop in selenium?
In Selenium WebDriver, we can perform drag and drop operations using the Actions class.

Steps to Perform Drag and Drop in Selenium
Identify the source element (the element to be dragged).
Identify the target element (where the source element needs to be dropped).
Use the Actions class to perform the drag-and-drop operation.

Method 1: Using dragAndDrop() Method

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.interactions.Actions;

public class DragDropExample {
    public static void main(String[] args) {
        // Set up the WebDriver
        WebDriver driver = new ChromeDriver();
        driver.get("https://jqueryui.com/droppable/"); // Sample drag and drop website

        // Switch to iframe if elements are inside an iframe
        driver.switchTo().frame(0);

        // Locate source and target elements
        WebElement source = driver.findElement(By.id("draggable"));
        WebElement target = driver.findElement(By.id("droppable"));

        // Create Actions class instance
        Actions actions = new Actions(driver);

        // Perform drag and drop
        actions.dragAndDrop(source, target).build().perform();

        // Close the browser
        driver.quit();
    }
}
Explanation:

We use driver.switchTo().frame(0); to switch to the iframe containing the draggable elements.
The dragAndDrop(source, target).perform(); method performs the action.

Method 2: Using clickAndHold(), moveToElement(), and release()
This approach is useful when dragAndDrop() does not work due to JavaScript handling.

// Perform drag and drop using clickAndHold and moveToElement
actions.clickAndHold(source)
       .moveToElement(target)
       .release()
       .build()
       .perform();
Explanation:

clickAndHold(source): Clicks on the element without releasing it.
moveToElement(target): Moves the element to the target.
release(): Releases the dragged element at the target location.

Method 3: Using moveByOffset() (Dragging by Coordinates)
If you need to drag an element by a specific offset (e.g., 100 pixels to the right and 50 pixels down):


actions.clickAndHold(source)
       .moveByOffset(100, 50) // Moves element by X=100, Y=50 pixels
       .release()
       .perform();
Conclusion
Use dragAndDrop() if the drag-and-drop action is straightforward.
Use clickAndHold(), moveToElement(), release() if the first method does not work.
Use moveByOffset() when dragging by coordinates.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
59)What is super keyword?

The super keyword in Java is used to refer to the parent class (superclass). It is primarily used for the following purposes:

1. Access Parent Class Constructor
The super keyword can be used to call the constructor of the parent class from the child class.

java
Copy
Edit
class Parent {
    Parent() {
        System.out.println("Parent class constructor");
    }
}

class Child extends Parent {
    Child() {
        super();  // Calls Parent class constructor
        System.out.println("Child class constructor");
    }
}

public class Main {
    public static void main(String[] args) {
        Child obj = new Child();
    }
}
Output:
Parent class constructor
Child class constructor
super(); calls the parent class constructor before executing the child class constructor.

2. Access Parent Class Methods
We can use super to call a method from the parent class when it is overridden in the child class.


class Parent {
    void display() {
        System.out.println("Display from Parent");
    }
}

class Child extends Parent {
    void display() {
        super.display();  // Calls Parent's display() method
        System.out.println("Display from Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.display();
    }
}
Output:


Display from Parent
Display from Child
Here, super.display(); calls the parent class's display() method inside the overridden method in the child class.

3. Access Parent Class Variables
If a child class has a variable with the same name as a parent class, we can use super to refer to the parent class variable.

class Parent {
    int num = 100;
}

class Child extends Parent {
    int num = 200;
    
    void show() {
        System.out.println("Child class num: " + num);         // Refers to child class variable
        System.out.println("Parent class num: " + super.num); // Refers to parent class variable
    }
}

public class Main {
    public static void main(String[] args) {
        Child obj = new Child();
        obj.show();
    }
}
Output:

Child class num: 200
Parent class num: 100
super.num refers to the parent class variable instead of the child class variable.

Key Points About super Keyword
Feature	                                                                 Description
Accesses Parent Class Constructor	                                     super(); calls the superclass constructor.
Calls Parent Class Methods	                                             super.methodName(); calls the parent class method even if overridden.
Accesses Parent Class Variables	                                         super.variableName; accesses the parent class variable when there is a name conflict.
Cannot Be Used in Static Methods	                                     super works only with instance methods, not in static methods.

When to Use super?
When calling a parent class constructor from a child class.
When accessing an overridden method of the parent class.
When accessing a parent class variable that is hidden by the child class.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
60)What is the Use of Drivers in Selenium?
In Selenium WebDriver, a driver is a software component that acts as a bridge between Selenium scripts and the actual browser. It allows Selenium to communicate with different web browsers, execute commands, and automate web interactions.

Types of Drivers in Selenium
1. Browser-Specific Drivers
Each web browser requires a specific driver to work with Selenium. Below are the common drivers:

Browser	             Driver Name	          Download Link
Google Chrome	     ChromeDriver	          Download
Mozilla Firefox	     GeckoDriver	          Download
Microsoft Edge	     EdgeDriver	              Download
Safari	             SafariDriver	          Built-in for macOS (Enable 'Allow Remote Automation' in Safari settings)
Example of ChromeDriver Setup in Java:


import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;

public class SeleniumTest {
    public static void main(String[] args) {
        // Set path for the ChromeDriver executable
        System.setProperty("webdriver.chrome.driver", "path/to/chromedriver");

        // Launch Chrome browser
        WebDriver driver = new ChromeDriver();

        // Open a website
        driver.get("https://www.google.com");

        // Close the browser
        driver.quit();
    }
}
🔹 System.setProperty() sets the path for the browser driver.
🔹 WebDriver driver = new ChromeDriver(); launches the browser.

2. Remote WebDriver (For Selenium Grid & Cloud Testing)
Used when running tests on remote machines or cloud-based Selenium grids (e.g., Selenium Grid, BrowserStack, Sauce Labs).
Requires RemoteWebDriver instead of a local browser driver.
Example of RemoteWebDriver:


import org.openqa.selenium.WebDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.DesiredCapabilities;
import java.net.MalformedURLException;
import java.net.URL;

public class RemoteSeleniumTest {
    public static void main(String[] args) throws MalformedURLException {
        // Set up remote Selenium Grid URL
        URL gridUrl = new URL("http://localhost:4444/wd/hub");

        // Define browser capabilities
        DesiredCapabilities capabilities = new DesiredCapabilities();
        capabilities.setBrowserName("chrome");

        // Create RemoteWebDriver instance
        WebDriver driver = new RemoteWebDriver(gridUrl, capabilities);

        // Open a website
        driver.get("https://www.google.com");

        // Close the browser
        driver.quit();
    }
}
🔹 Used when running Selenium tests on a cloud/grid instead of a local machine.

Key Uses of WebDrivers in Selenium
Automates Browser Actions: Enables Selenium to open, interact, and close browsers.
Supports Cross-Browser Testing: Works with Chrome, Firefox, Edge, Safari, etc..
Executes Selenium Commands: Runs Selenium functions like click(), sendKeys(), getText(), etc.
Integrates with Remote Testing: Supports Selenium Grid and cloud testing.
Handles Headless Browser Testing: Works with headless browsers for faster execution (e.g., Chrome Headless).
Conclusion
Selenium WebDriver needs a browser driver to communicate with different browsers.
Browser-specific drivers (like ChromeDriver, GeckoDriver) are required for local testing.
RemoteWebDriver is used for Selenium Grid or cloud-based execution.
--------------------------------------------------------------------------------------------------------------------------------------------------------------
61)What is BDD (Behavior-Driven Development)?
BDD (Behavior-Driven Development) is a software development approach that focuses on collaboration between developers, testers, and business stakeholders. 
It helps teams define clear, understandable requirements in a natural language format using simple Given-When-Then scenarios.

It extends Test-Driven Development (TDD) by writing test cases in business-readable language, making them more user-friendly and easier to understand.

Key Features of BDD
Uses Natural Language (Gherkin Syntax)

Test scenarios are written in plain English (e.g., "Given-When-Then").
Example:

Given I am on the login page
When I enter valid credentials
Then I should be redirected to the dashboard
Encourages Collaboration

Brings developers, testers, and business analysts together.
Ensures clarity in requirements and reduces misunderstandings.
Automates Functional Tests

BDD frameworks like Cucumber, SpecFlow, Behave integrate tests with automation tools.
Enhances Test Documentation

BDD scenarios serve as living documentation for system behavior.
Example of BDD in Cucumber (Java)
Step 1: Write a Feature File (login.feature)

Feature: Login Functionality

  Scenario: Successful Login with Valid Credentials
    Given I am on the login page
    When I enter valid username and password
    Then I should be redirected to the dashboard
Step 2: Implement Step Definitions (LoginSteps.java)


import io.cucumber.java.en.*;

public class LoginSteps {
    
    @Given("I am on the login page")
    public void openLoginPage() {
        System.out.println("User is on the login page");
    }

    @When("I enter valid username and password")
    public void enterCredentials() {
        System.out.println("User enters valid credentials");
    }

    @Then("I should be redirected to the dashboard")
    public void verifyDashboard() {
        System.out.println("User is redirected to the dashboard");
    }
}
Step 3: Run Tests with JUnit/Cucumber Runner


import org.junit.runner.RunWith;
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;

@RunWith(Cucumber.class)
@CucumberOptions(features="src/test/resources/features", glue={"stepDefinitions"})
public class TestRunner {
}
Popular BDD Tools
Tool	Language	Purpose
Cucumber	Java, JavaScript, Python	BDD framework for writing feature files
SpecFlow	.NET (C#)	BDD for C# applications
Behave	Python	BDD framework for Python
JBehave	Java	BDD for Java applications
Advantages of BDD
✅ Improves Collaboration: Non-technical stakeholders can read & understand test cases.
✅ Reduces Misunderstandings: Ensures all team members are on the same page.
✅ Enhances Automation: Test cases are automated and executable.
✅ Better Documentation: Feature files act as living documentation.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
62)How is a Jenkins Pipeline Built?
A Jenkins Pipeline is a series of automated steps that define how software builds, tests, and deploys. It is written using a Jenkinsfile, which is a script written in Groovy DSL (Domain-Specific Language).

There are two types of Jenkins Pipelines:

Declarative Pipeline (Simpler, recommended)
Scripted Pipeline (More flexible, but complex)
1️⃣ Steps to Build a Jenkins Pipeline
Step 1: Install Jenkins & Required Plugins
Install Jenkins and required plugins (e.g., Pipeline, Git, Docker, etc.).
Ensure Jenkins has access to required tools (e.g., Java, Maven, Gradle, Docker, Kubernetes).
Step 2: Create a Jenkinsfile (Pipeline Script)
The Jenkinsfile defines the pipeline stages.

🔹 Example of a Declarative Pipeline (Jenkinsfile)

pipeline {
    agent any  // Runs on any available Jenkins agent

    stages {
        stage('Clone Repository') {
            steps {
                git 'https://github.com/example/repository.git'
            }
        }

        stage('Build') {
            steps {
                sh 'mvn clean package'  // Build using Maven
            }
        }

        stage('Test') {
            steps {
                sh 'mvn test'  // Run unit tests
            }
        }

        stage('Deploy') {
            steps {
                echo 'Deploying application...'  
                // Add deployment commands (e.g., Docker, Kubernetes, AWS, etc.)
            }
        }
    }
}
✅ Breakdown of the Pipeline:

agent any → Runs on any available Jenkins worker/node.
stage('Clone Repository') → Fetches the source code.
stage('Build') → Builds the project using Maven.
stage('Test') → Runs tests.
stage('Deploy') → Deploys the application.

Step 3: Create a New Pipeline in Jenkins
Open Jenkins Dashboard → Click on "New Item".
Select "Pipeline" → Enter a name → Click OK.
Scroll down to Pipeline Section → Choose Pipeline Script from SCM.
Select Git, then enter your repository URL (e.g., GitHub, GitLab, Bitbucket).
Specify the branch and Jenkinsfile location (e.g., Jenkinsfile in the root directory).
Click Save and Build Now to start the pipeline.
2️⃣ Alternative: Scripted Pipeline (More Flexible)
A scripted pipeline is written in plain Groovy.


node {
    stage('Clone Repository') {
        git 'https://github.com/example/repository.git'
    }

    stage('Build') {
        sh 'mvn clean package'
    }

    stage('Test') {
        sh 'mvn test'
    }

    stage('Deploy') {
        echo 'Deploying application...'
    }
}
✅ Key Difference:

Scripted Pipelines use node {} instead of pipeline {}.
More flexible but harder to read compared to Declarative Pipelines.
3️⃣ Triggering the Pipeline
Jenkins Pipelines can be triggered in different ways: ✅ Manually: Click "Build Now" in Jenkins.
✅ Automatically via Webhook: Set up GitHub Webhooks to trigger builds on commits.
✅ Scheduled: Use cron syntax to trigger builds (e.g., H/15 * * * * for every 15 mins).
✅ After Another Job: Use post { success { } } to trigger another job after success.

4️⃣ Jenkins Pipeline with Docker
To build and run an application inside a Docker container, modify the Jenkinsfile:


pipeline {
    agent { docker { image 'maven:3.8.4' } }

    stages {
        stage('Build') {
            steps {
                sh 'mvn clean package'
            }
        }

        stage('Test') {
            steps {
                sh 'mvn test'
            }
        }

        stage('Deploy') {
            steps {
                sh 'docker build -t my-app .'
                sh 'docker run -d -p 8080:8080 my-app'
            }
        }
    }
}
Conclusion
🔹 Jenkins Pipelines automate the CI/CD process using Jenkinsfiles.
🔹 Declarative Pipelines are simpler and recommended.
🔹 Scripted Pipelines provide more control but are harder to manage.
🔹 Pipelines can integrate with GitHub, Docker, AWS, Kubernetes, etc.
--------------------------------------------------------------------------------------------------------------------------------------------------
63)What is delete bug cycle


The Delete Bug Cycle is not a standard term in software development, but it can be interpreted in different ways depending on the context. Here are a few possible meanings:

Bug Reappearance Cycle: If a developer deletes or marks a bug as resolved without properly fixing it, it may reappear in later testing or production, 
leading to a cycle where the same bug is repeatedly reported and closed without a proper fix.

Bug Lifecycle Management Issue: In some bug-tracking systems, improper handling of bug statuses (e.g., deleting bugs instead of marking them as resolved or invalid) 
can cause confusion and inefficiencies in the development cycle.

Automated Deletion of Bugs: In CI/CD pipelines, automated tools might delete bug reports that don't meet certain criteria, 
causing a cycle where unresolved bugs keep reappearing but get deleted instead of properly addressed.
-----------------------------------------------------------------------------------------------------------------------------------------------------------
64)How to enter text into text field without using sendKeys()?
- JavascriptExecutor can be used for this purpose
WebElement searchbox=driver.findElement(By.name("search"));
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].value'imac'",searchBox);

-----------------------------------------------------------------------------------------------------------------------------------------------------
65)How to pause execution using Selenium WebDriver?

In Selenium WebDriver, you can pause execution using different methods depending on your needs:

1. Using Thread.sleep() (Not Recommended)
Pauses execution for a fixed time.
Cons: Not dynamic, can cause unnecessary delays.

Thread.sleep(5000); // Pauses for 5 seconds
Requires handling InterruptedException:

try {
    Thread.sleep(5000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
2. Using WebDriverWait (Recommended)
Waits dynamically until a condition is met.
Example: Waiting for an element to be visible

WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id("example")));

3. Using FluentWait (Advanced)
Allows polling intervals and handling exceptions.

Wait<WebDriver> wait = new FluentWait<>(driver)
    .withTimeout(Duration.ofSeconds(10))
    .pollingEvery(Duration.ofSeconds(1))
    .ignoring(NoSuchElementException.class);

WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("example")));
4. Using JavaScript setTimeout (Alternative)
Executes JavaScript to pause execution.

JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeAsyncScript("window.setTimeout(arguments[arguments.length - 1], 5000);");
5. Using Debug Breakpoints (For Debugging)
If debugging in an IDE, place breakpoints in your code.
---------------------------------------------------------------------------------------------------------------------------------------------------------
66)How to download a file in Selenium WebDriver? 
1. Create an object for ChromeOptions 
	1. ChromeOptions options = new ChromeOptions();
2. Write the below ChromeOptions code for setting the download path 
	1. HashMap<String, Object> chromePrefs = new HashMap<String, Object>();
	2. chromePrefs.put("profile.default_content_settings.popups", 0);
	3. chromePrefs.put("download.default_directory", downloadFilepath);
	4. options.setExperimentalOption("prefs",chromePrefs);
3. WebDriver driver = new ChromeDriver(options);

sample program code:

package dpack;

import java.io.File;
import java.util.HashMap;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.testng.Assert;
import org.testng.annotations.Test;

import io.github.bonigarcia.wdm.WebDriverManager;

public class Demo {

	@Test
	public void downloadFile() throws InterruptedException {
		
		ChromeOptions options = new ChromeOptions();
		String downloadPath = System.getProperty("user.dir");

		HashMap<String, Object> chromePrefs = new HashMap<String, Object>();
		chromePrefs.put("profile.default_content_settings.popups", 0);
		chromePrefs.put("download.default_directory", downloadPath);
		
		options.setExperimentalOption("prefs",chromePrefs);
		
		WebDriverManager.chromedriver().setup();
		WebDriver driver = new ChromeDriver(options);
		driver.get("http://omayo.blogspot.com/p/page7.html");
		driver.manage().window().maximize();
		driver.findElement(By.linkText("ZIP file")).click();
		
		Thread.sleep(5000);
		
		String filePathUpdated = downloadPath+"\\DownloadDemo-master.zip";
		
		File file = new File(filePathUpdated);
		
		Assert.assertTrue(file.exists());
		
		if(file.exists()) {
			
			file.delete();
			
		}

		
	}

}
---------------------------------------------------------------------------------------------------------------------------------------------------------------
67)How to upload a file in Selenium WebDriver? 
- sendKeys() can be used to upload a file in Selenium WebDriver
  Uploading the files from a workspace folder instead of local folder
- Here is the code:
  driver.findElement(By.id("upload")).sendKeys("Path of the file");
  
  
  public static void main(String[] args)throws InterruptedException {

				//WebDriverManager.chromedriver().setup();
			
				WebDriver driver = new ChromeDriver();
				
				driver.manage().window().maximize();
				
				driver.get("http://tutorialsninja.com/demo/"); 
				
				String projectPath = System.getProperty("user.dir");
				driver.findElement(By.id("uploadfile")).sendkeys(projectPath+"\\files\\wave.jpg");
				}
				}
	--------------------------------------------------------------------------------------------------------
68)How to login into any site using Selenium if it is showing an authentication pop-up? 
- https://the-internet.herokuapp.com/
- driver.get("http://admin:admin@yoururl.com");

-------------------------------------------------------------------------------------------------------------
69)How to delete cookies in Selenium?
driver.manage().deleteAllCookies();
------------------------------------------------------------------------------------------------------------
70) How to Set Up Extent Reports in TestNG Framework
💡 Question: How do you configure and use Extent Reports in a TestNG framework?

📌 What is Extent Reports?
Extent Reports is an advanced reporting library for Selenium + TestNG that provides interactive and detailed test execution reports.

🔹 Step-by-Step Guide to Setting Up Extent Reports in TestNG
🛠 1. Add Extent Reports Dependency
If you are using Maven, add this dependency to your pom.xml:


<dependencies>
    <dependency>
        <groupId>com.aventstack</groupId>
        <artifactId>extentreports</artifactId>
        <version>5.0.9</version>
    </dependency>
</dependencies>
🔹 If you are not using Maven, download the Extent Reports JAR from Maven Repository and add it to your project.

🛠 2. Create a Base Class for Extent Reports
Create a BaseTest.java class that initializes and flushes the report.


import com.aventstack.extentreports.ExtentReports;
import com.aventstack.extentreports.ExtentTest;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;

public class BaseTest {
    public static ExtentReports extent;
    public static ExtentTest test;
    
    @BeforeClass
    public void setupExtentReport() {
        ExtentSparkReporter htmlReporter = new ExtentSparkReporter("test-output/ExtentReport.html");
        extent = new ExtentReports();
        extent.attachReporter(htmlReporter);
        
        // Set system details (optional)
        extent.setSystemInfo("OS", "Windows");
        extent.setSystemInfo("Browser", "Chrome");
    }

    @AfterClass
    public void tearDown() {
        extent.flush(); // Save the report
    }
}
🛠 3. Implement Extent Reports in TestNG Tests
Create a test class TestExample.java and extend BaseTest.


import org.testng.Assert;
import org.testng.annotations.Test;
import com.aventstack.extentreports.Status;

public class TestExample extends BaseTest {

    @Test
    public void testLogin() {
        test = extent.createTest("Login Test");
        test.log(Status.INFO, "Starting login test");
        
        String expectedTitle = "Dashboard";
        String actualTitle = "Dashboard"; // Assume fetched from WebDriver
        
        Assert.assertEquals(actualTitle, expectedTitle, "Title Mismatch");
        test.pass("Login test passed!");
    }

    @Test
    public void testInvalidLogin() {
        test = extent.createTest("Invalid Login Test");
        test.log(Status.INFO, "Starting invalid login test");
        
        boolean loginFailed = true; // Assume Selenium WebDriver result
        
        Assert.assertTrue(loginFailed, "Login should fail");
        test.pass("Invalid login test passed!");
    }
}
✅ Explanation:

extent.createTest("Test Name") → Creates a test in the report.
test.log(Status.INFO, "Message") → Logs steps in the report.
test.pass("Message") → Marks the test as passed.
extent.flush() → Generates the report.

🛠 4. Run Tests & Generate Reports


Execute the tests via your TestNG XML or directly in IDE.


After execution, open test-output/ExtentReport.html in a browser.
🎯 Key Features of Extent Reports
✅ Attractive HTML Reports
✅ Supports Screenshots
✅ Logging with Pass/Fail/Skip status
✅ Integration with TestNG Listeners



























